/* eslint-disable */
/**
 * Generated by orval
 * Do not edit manually. Run "npm run generate-client" instead.
 * Airbyte Configuration API
 * Airbyte Configuration API
[https://airbyte.io](https://airbyte.io).

This API is a collection of HTTP RPC-style methods. While it is not a REST API, those familiar with REST should find the conventions of this API recognizable.

Here are some conventions that this API follows:
* All endpoints are http POST methods.
* All endpoints accept data via `application/json` request bodies. The API does not accept any data via query params.
* The naming convention for endpoints is: localhost:8000/{VERSION}/{METHOD_FAMILY}/{METHOD_NAME} e.g. `localhost:8000/v1/connections/create`.
* For all `update` methods, the whole object must be passed in, even the fields that did not change.

Change Management:
* The major version of the API endpoint can be determined / specified in the URL `localhost:8080/v1/connections/create`
* Minor version bumps will be invisible to the end user. The user cannot specify minor versions in requests.
* All backwards incompatible changes will happen in major version bumps. We will not make backwards incompatible changes in minor version bumps. Examples of non-breaking changes (includes but not limited to...):
  * Adding fields to request or response bodies.
  * Adding new HTTP endpoints.
* All `web_backend` APIs are not considered public APIs and are not guaranteeing backwards compatibility.

 * OpenAPI spec version: 1.0.0
 */
/**
 * Input failed validation
 */
export type InvalidInputResponseResponse = InvalidInputExceptionInfo;

export interface KnownExceptionInfo {
  message: string;
  exceptionClassName?: string;
  exceptionStack?: string[];
  rootCauseExceptionClassName?: string;
  rootCauseExceptionStack?: string[];
}

/**
 * Exception occurred; see message for details.
 */
export type ExceptionResponseResponse = KnownExceptionInfo;

export interface NotFoundKnownExceptionInfo {
  id?: string;
  message: string;
  exceptionClassName?: string;
  exceptionStack?: string[];
  rootCauseExceptionClassName?: string;
  rootCauseExceptionStack?: string[];
}

/**
 * Object with given id was not found.
 */
export type NotFoundResponseResponse = NotFoundKnownExceptionInfo;

export interface InvalidInputProperty {
  propertyPath: string;
  invalidValue?: string;
  message?: string;
}

export interface InvalidInputExceptionInfo {
  message: string;
  exceptionClassName?: string;
  exceptionStack?: string[];
  validationErrors: InvalidInputProperty[];
}

export type UploadReadStatus =
  typeof UploadReadStatus[keyof typeof UploadReadStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UploadReadStatus = {
  succeeded: 'succeeded',
  failed: 'failed',
} as const;

export type ResourceId = string;

export interface ImportRequestBody {
  resourceId: ResourceId;
  workspaceId: WorkspaceId;
}

export interface UploadRead {
  status: UploadReadStatus;
  resourceId?: ResourceId;
}

export type ImportReadStatus =
  typeof ImportReadStatus[keyof typeof ImportReadStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ImportReadStatus = {
  succeeded: 'succeeded',
  failed: 'failed',
} as const;

export interface ImportRead {
  status: ImportReadStatus;
  reason?: string;
}

/**
 * Tarball Archive (.tar.gz) of Airbyte Configuration and Database
 */
export type AirbyteArchive = Blob;

export type DestinationSyncMode =
  typeof DestinationSyncMode[keyof typeof DestinationSyncMode];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DestinationSyncMode = {
  append: 'append',
  overwrite: 'overwrite',
  append_dedup: 'append_dedup',
} as const;

export type SyncMode = typeof SyncMode[keyof typeof SyncMode];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SyncMode = {
  full_refresh: 'full_refresh',
  incremental: 'incremental',
} as const;

export interface WebBackendConnectionRead {
  connectionId: ConnectionId;
  name: string;
  namespaceDefinition?: NamespaceDefinitionType;
  /** Used when namespaceDefinition is 'customformat'. If blank then behaves like namespaceDefinition = 'destination'. If "${SOURCE_NAMESPACE}" then behaves like namespaceDefinition = 'source'. */
  namespaceFormat?: string;
  /** Prefix that will be prepended to the name of each stream when it is written to the destination. */
  prefix?: string;
  sourceId: SourceId;
  destinationId: DestinationId;
  syncCatalog: AirbyteCatalog;
  schedule?: ConnectionSchedule;
  status: ConnectionStatus;
  operationIds?: OperationId[];
  source: SourceRead;
  destination: DestinationRead;
  operations?: OperationRead[];
  /** epoch time of the latest sync job. null if no sync job has taken place. */
  latestSyncJobCreatedAt?: number;
  latestSyncJobStatus?: JobStatus;
  isSyncing: boolean;
  resourceRequirements?: ResourceRequirements;
  catalogId?: string;
  catalogDiff?: CatalogDiff;
}

export interface WebBackendConnectionReadList {
  connections: WebBackendConnectionRead[];
}

export type SetInstancewideDestinationOauthParamsRequestBodyParams = {
  [key: string]: any;
};

export interface SetInstancewideDestinationOauthParamsRequestBody {
  destinationDefinitionId: DestinationDefinitionId;
  params: SetInstancewideDestinationOauthParamsRequestBodyParams;
}

export type SetInstancewideSourceOauthParamsRequestBodyParams = {
  [key: string]: any;
};

export interface SetInstancewideSourceOauthParamsRequestBody {
  sourceDefinitionId: SourceDefinitionId;
  params: SetInstancewideSourceOauthParamsRequestBodyParams;
}

export interface CompleteOAuthResponse {
  [key: string]: any;
}

/**
 * The query parameters present in the redirect URL after a user granted consent e.g auth code
 */
export type CompleteDestinationOAuthRequestQueryParams = { [key: string]: any };

export interface CompleteDestinationOAuthRequest {
  destinationDefinitionId: DestinationDefinitionId;
  workspaceId: WorkspaceId;
  /** When completing OAuth flow to gain an access token, some API sometimes requires to verify that the app re-send the redirectUrl that was used when consent was given. */
  redirectUrl?: string;
  /** The query parameters present in the redirect URL after a user granted consent e.g auth code */
  queryParams?: CompleteDestinationOAuthRequestQueryParams;
  oAuthInputConfiguration?: OAuthInputConfiguration;
}

/**
 * The query parameters present in the redirect URL after a user granted consent e.g auth code
 */
export type CompleteSourceOauthRequestQueryParams = { [key: string]: any };

export interface CompleteSourceOauthRequest {
  sourceDefinitionId: SourceDefinitionId;
  workspaceId: WorkspaceId;
  /** When completing OAuth flow to gain an access token, some API sometimes requires to verify that the app re-send the redirectUrl that was used when consent was given. */
  redirectUrl?: string;
  /** The query parameters present in the redirect URL after a user granted consent e.g auth code */
  queryParams?: CompleteSourceOauthRequestQueryParams;
  oAuthInputConfiguration?: OAuthInputConfiguration;
}

export interface OAuthConsentRead {
  consentUrl: string;
}

export type AdvancedAuthAuthFlowType =
  typeof AdvancedAuthAuthFlowType[keyof typeof AdvancedAuthAuthFlowType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AdvancedAuthAuthFlowType = {
  oauth20: 'oauth2.0',
  oauth10: 'oauth1.0',
} as const;

export interface AdvancedAuth {
  authFlowType?: AdvancedAuthAuthFlowType;
  /** Json Path to a field in the connectorSpecification that should exist for the advanced auth to be applicable. */
  predicateKey?: string[];
  /** Value of the predicate_key fields for the advanced auth to be applicable. */
  predicateValue?: string;
  oauthConfigSpecification?: OAuthConfigSpecification;
}

/**
 * The values required to configure OAuth flows. The schema for this must match the `OAuthConfigSpecification.oauthUserInputFromConnectorConfigSpecification` schema.
 */
export type OAuthConfiguration = unknown;

export interface OAuthConfigSpecification {
  /** OAuth specific blob. This is a Json Schema used to validate Json configurations used as input to OAuth.
Must be a valid non-nested JSON that refers to properties from ConnectorSpecification.connectionSpecification
using special annotation 'path_in_connector_config'.
These are input values the user is entering through the UI to authenticate to the connector, that might also shared
as inputs for syncing data via the connector.

Examples:

if no connector values is shared during oauth flow, oauth_user_input_from_connector_config_specification=[]
if connector values such as 'app_id' inside the top level are used to generate the API url for the oauth flow,
  oauth_user_input_from_connector_config_specification={
    app_id: {
      type: string
      path_in_connector_config: ['app_id']
    }
  }
if connector values such as 'info.app_id' nested inside another object are used to generate the API url for the oauth flow,
  oauth_user_input_from_connector_config_specification={
    app_id: {
      type: string
      path_in_connector_config: ['info', 'app_id']
    }
  } */
  oauthUserInputFromConnectorConfigSpecification?: OAuthConfiguration;
  /** OAuth specific blob. This is a Json Schema used to validate Json configurations produced by the OAuth flows as they are
returned by the distant OAuth APIs.
Must be a valid JSON describing the fields to merge back to `ConnectorSpecification.connectionSpecification`.
For each field, a special annotation `path_in_connector_config` can be specified to determine where to merge it,

Examples:

    complete_oauth_output_specification={
      refresh_token: {
        type: string,
        path_in_connector_config: ['credentials', 'refresh_token']
      }
    } */
  completeOAuthOutputSpecification?: OAuthConfiguration;
  /** OAuth specific blob. This is a Json Schema used to validate Json configurations persisted as Airbyte Server configurations.
Must be a valid non-nested JSON describing additional fields configured by the Airbyte Instance or Workspace Admins to be used by the
server when completing an OAuth flow (typically exchanging an auth code for refresh token).

Examples:

    complete_oauth_server_input_specification={
      client_id: {
        type: string
      },
      client_secret: {
        type: string
      }
    } */
  completeOAuthServerInputSpecification?: OAuthConfiguration;
  /** OAuth specific blob. This is a Json Schema used to validate Json configurations persisted as Airbyte Server configurations that
also need to be merged back into the connector configuration at runtime.
This is a subset configuration of `complete_oauth_server_input_specification` that filters fields out to retain only the ones that
are necessary for the connector to function with OAuth. (some fields could be used during oauth flows but not needed afterwards, therefore
they would be listed in the `complete_oauth_server_input_specification` but not `complete_oauth_server_output_specification`)
Must be a valid non-nested JSON describing additional fields configured by the Airbyte Instance or Workspace Admins to be used by the
connector when using OAuth flow APIs.
These fields are to be merged back to `ConnectorSpecification.connectionSpecification`.
For each field, a special annotation `path_in_connector_config` can be specified to determine where to merge it,

Examples:

      complete_oauth_server_output_specification={
        client_id: {
          type: string,
          path_in_connector_config: ['credentials', 'client_id']
        },
        client_secret: {
          type: string,
          path_in_connector_config: ['credentials', 'client_secret']
        }
      } */
  completeOAuthServerOutputSpecification?: OAuthConfiguration;
}

export type OAuthInputConfiguration = OAuthConfiguration;

export interface DestinationOauthConsentRequest {
  destinationDefinitionId: DestinationDefinitionId;
  workspaceId: WorkspaceId;
  /** The url to redirect to after getting the user consent */
  redirectUrl: string;
  oAuthInputConfiguration?: OAuthInputConfiguration;
}

export interface SourceOauthConsentRequest {
  sourceDefinitionId: SourceDefinitionId;
  workspaceId: WorkspaceId;
  /** The url to redirect to after getting the user consent */
  redirectUrl: string;
  oAuthInputConfiguration?: OAuthInputConfiguration;
}

export type DbMigrationState =
  typeof DbMigrationState[keyof typeof DbMigrationState];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DbMigrationState = {
  pending: 'pending',
  above_target: 'above_target',
  below_baseline: 'below_baseline',
  baseline: 'baseline',
  ignored: 'ignored',
  missing_success: 'missing_success',
  missing_failed: 'missing_failed',
  success: 'success',
  undone: 'undone',
  available: 'available',
  failed: 'failed',
  out_of_order: 'out_of_order',
  future_success: 'future_success',
  future_failed: 'future_failed',
  outdated: 'outdated',
  superseded: 'superseded',
  deleted: 'deleted',
} as const;

export interface DbMigrationRead {
  migrationType: string;
  migrationVersion: string;
  migrationDescription: string;
  migrationState?: DbMigrationState;
  migratedBy?: string;
  migratedAt?: number;
  migrationScript?: string;
}

export interface DbMigrationExecutionRead {
  initialVersion?: string;
  targetVersion?: string;
  executedMigrations?: DbMigrationRead[];
}

export interface DbMigrationReadList {
  migrations?: DbMigrationRead[];
}

/**
 * optional resource requirements to run workers (blank for unbounded allocations)
 */
export interface ResourceRequirements {
  cpu_request?: string;
  cpu_limit?: string;
  memory_request?: string;
  memory_limit?: string;
}

/**
 * enum that describes the different types of jobs that the platform runs.
 */
export type JobType = typeof JobType[keyof typeof JobType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const JobType = {
  get_spec: 'get_spec',
  check_connection: 'check_connection',
  discover_schema: 'discover_schema',
  sync: 'sync',
  reset_connection: 'reset_connection',
  connection_updater: 'connection_updater',
  replicate: 'replicate',
} as const;

/**
 * sets resource requirements for a specific job type for an actor definition. these values override the default, if both are set.
 */
export interface JobTypeResourceLimit {
  jobType: JobType;
  resourceRequirements: ResourceRequirements;
}

/**
 * actor definition specific resource requirements. if default is set, these are the requirements that should be set for ALL jobs run for this actor definition. it is overriden by the job type specific configurations. if not set, the platform will use defaults. these values will be overriden by configuration at the connection level.
 */
export interface ActorDefinitionResourceRequirements {
  default?: ResourceRequirements;
  jobSpecific?: JobTypeResourceLimit[];
}

/**
 * JSONSchema representation of the field
 */
export interface FieldSchema {
  [key: string]: any;
}

/**
 * A field name is a list of strings that form the path to the field.
 */
export type FieldName = string[];

export interface FieldSchemaUpdate {
  oldSchema: FieldSchema;
  newSchema: FieldSchema;
}

export interface FieldRemove {
  schema?: FieldSchema;
}

export interface FieldAdd {
  schema?: FieldSchema;
}

export type FieldTransformTransformType =
  typeof FieldTransformTransformType[keyof typeof FieldTransformTransformType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const FieldTransformTransformType = {
  add_field: 'add_field',
  remove_field: 'remove_field',
  update_field_schema: 'update_field_schema',
} as const;

/**
 * Describes the difference between two Streams.
 */
export interface FieldTransform {
  transformType: FieldTransformTransformType;
  fieldName: FieldName;
  addField?: FieldAdd;
  removeField?: FieldRemove;
  updateFieldSchema?: FieldSchemaUpdate;
}

export type StreamTransformTransformType =
  typeof StreamTransformTransformType[keyof typeof StreamTransformTransformType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const StreamTransformTransformType = {
  add_stream: 'add_stream',
  remove_stream: 'remove_stream',
  update_stream: 'update_stream',
} as const;

export interface StreamTransform {
  transformType: StreamTransformTransformType;
  streamDescriptor: StreamDescriptor;
  /** list of field transformations. order does not matter. */
  updateStream?: FieldTransform[];
}

/**
 * Describes the difference between two Airbyte catalogs.
 */
export interface CatalogDiff {
  /** list of stream transformations. order does not matter. */
  transforms: StreamTransform[];
}

export type ConnectionStateType =
  typeof ConnectionStateType[keyof typeof ConnectionStateType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ConnectionStateType = {
  global: 'global',
  stream: 'stream',
  legacy: 'legacy',
  not_set: 'not_set',
} as const;

export interface StateBlob {
  [key: string]: any;
}

export interface StreamState {
  streamDescriptor: StreamDescriptor;
  streamState?: StateBlob;
}

export interface GlobalState {
  shared_state?: StateBlob;
  streamStates: StreamState[];
}

/**
 * Contains the state for a connection. The stateType field identifies what type of state it is. Only the field corresponding to that type will be set, the rest will be null. If stateType=not_set, then none of the fields will be set.
 */
export interface ConnectionState {
  stateType: ConnectionStateType;
  connectionId: ConnectionId;
  state?: StateBlob;
  streamState?: StreamState[];
  globalState?: GlobalState;
}

export type CheckConnectionReadStatus =
  typeof CheckConnectionReadStatus[keyof typeof CheckConnectionReadStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CheckConnectionReadStatus = {
  succeeded: 'succeeded',
  failed: 'failed',
} as const;

export interface CheckConnectionRead {
  status: CheckConnectionReadStatus;
  message?: string;
  jobInfo: SynchronousJobRead;
}

export interface HealthCheckRead {
  available: boolean;
}

export interface Pagination {
  pageSize?: number;
  rowOffset?: number;
}

export interface LogRead {
  logLines: string[];
}

export interface AttemptInfoRead {
  attempt: AttemptRead;
  logs: LogRead;
}

export interface JobDebugInfoRead {
  job: JobDebugRead;
  attempts: AttemptInfoRead[];
}

export interface JobInfoRead {
  job: JobRead;
  attempts: AttemptInfoRead[];
}

export type AttemptStatus = typeof AttemptStatus[keyof typeof AttemptStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AttemptStatus = {
  running: 'running',
  failed: 'failed',
  succeeded: 'succeeded',
} as const;

/**
 * Categorizes well known errors into types for programmatic handling. If not set, the type of error is not well known.
 */
export type AttemptFailureType =
  typeof AttemptFailureType[keyof typeof AttemptFailureType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AttemptFailureType = {
  config_error: 'config_error',
  system_error: 'system_error',
  manual_cancellation: 'manual_cancellation',
} as const;

/**
 * Indicates where the error originated. If not set, the origin of error is not well known.
 */
export type AttemptFailureOrigin =
  typeof AttemptFailureOrigin[keyof typeof AttemptFailureOrigin];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AttemptFailureOrigin = {
  source: 'source',
  destination: 'destination',
  replication: 'replication',
  persistence: 'persistence',
  normalization: 'normalization',
  dbt: 'dbt',
  airbyte_platform: 'airbyte_platform',
} as const;

export interface AttemptFailureReason {
  failureOrigin?: AttemptFailureOrigin;
  failureType?: AttemptFailureType;
  externalMessage?: string;
  internalMessage?: string;
  stacktrace?: string;
  /** True if it is known that retrying may succeed, e.g. for a transient failure. False if it is known that a retry will not succeed, e.g. for a configuration issue. If not set, retryable status is not well known. */
  retryable?: boolean;
  timestamp: number;
}

export interface AttemptFailureSummary {
  failures: AttemptFailureReason[];
  /** True if the number of committed records for this attempt was greater than 0. False if 0 records were committed. If not set, the number of committed records is unknown. */
  partialSuccess?: boolean;
}

export interface AttemptStats {
  recordsEmitted?: number;
  bytesEmitted?: number;
  stateMessagesEmitted?: number;
  recordsCommitted?: number;
}

export interface AttemptStreamStats {
  streamName: string;
  stats: AttemptStats;
}

export interface AttemptRead {
  id: number;
  status: AttemptStatus;
  createdAt: number;
  updatedAt: number;
  endedAt?: number;
  bytesSynced?: number;
  recordsSynced?: number;
  totalStats?: AttemptStats;
  streamStats?: AttemptStreamStats[];
  failureSummary?: AttemptFailureSummary;
}

export type JobStatus = typeof JobStatus[keyof typeof JobStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const JobStatus = {
  pending: 'pending',
  running: 'running',
  incomplete: 'incomplete',
  failed: 'failed',
  succeeded: 'succeeded',
  cancelled: 'cancelled',
} as const;

export interface JobDebugRead {
  id: JobId;
  configType: JobConfigType;
  configId: string;
  status: JobStatus;
  airbyteVersion: string;
  sourceDefinition: SourceDefinitionRead;
  destinationDefinition: DestinationDefinitionRead;
}

export interface StreamDescriptor {
  name: string;
  namespace?: string;
}

/**
 * contains information about how a reset was configured. only populated if the job was a reset.
 */
export interface ResetConfig {
  streamsToReset?: StreamDescriptor[];
}

export interface JobIdRequestBody {
  id: JobId;
}

export type JobConfigType = typeof JobConfigType[keyof typeof JobConfigType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const JobConfigType = {
  check_connection_source: 'check_connection_source',
  check_connection_destination: 'check_connection_destination',
  discover_schema: 'discover_schema',
  get_spec: 'get_spec',
  sync: 'sync',
  reset_connection: 'reset_connection',
} as const;

export interface SynchronousJobRead {
  id: string;
  configType: JobConfigType;
  /** only present if a config id was provided. */
  configId?: string;
  createdAt: number;
  endedAt: number;
  succeeded: boolean;
  logs?: LogRead;
}

export interface JobRead {
  id: JobId;
  configType: JobConfigType;
  configId: string;
  createdAt: number;
  updatedAt: number;
  status: JobStatus;
  resetConfig?: ResetConfig;
}

export interface JobWithAttemptsRead {
  job?: JobRead;
  attempts?: AttemptRead[];
}

export interface JobReadList {
  jobs: JobWithAttemptsRead[];
}

export interface JobListRequestBody {
  configTypes: JobConfigType[];
  configId: string;
  pagination?: Pagination;
}

export type JobId = number;

export type DataType = typeof DataType[keyof typeof DataType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DataType = {
  string: 'string',
  number: 'number',
  boolean: 'boolean',
  object: 'object',
  array: 'array',
} as const;

/**
 * the mutable part of the stream to configure the destination
 */
export interface AirbyteStreamConfiguration {
  syncMode: SyncMode;
  /** Path to the field that will be used to determine if a record is new or modified since the last sync. This field is REQUIRED if `sync_mode` is `incremental`. Otherwise it is ignored. */
  cursorField?: string[];
  destinationSyncMode: DestinationSyncMode;
  /** Paths to the fields that will be used as primary key. This field is REQUIRED if `destination_sync_mode` is `*_dedup`. Otherwise it is ignored. */
  primaryKey?: string[][];
  /** Alias name to the stream to be used in the destination */
  aliasName?: string;
  selected?: boolean;
}

/**
 * Stream schema using Json Schema specs.
 */
export interface StreamJsonSchema {
  [key: string]: any;
}

/**
 * the immutable schema defined by the source
 */
export interface AirbyteStream {
  /** Stream's name. */
  name: string;
  jsonSchema?: StreamJsonSchema;
  supportedSyncModes?: SyncMode[];
  /** If the source defines the cursor field, then any other cursor field inputs will be ignored. If it does not, either the user_provided one is used, or the default one is used as a backup. */
  sourceDefinedCursor?: boolean;
  /** Path to the field that will be used to determine if a record is new or modified since the last sync. If not provided by the source, the end user will have to specify the comparable themselves. */
  defaultCursorField?: string[];
  /** If the source defines the primary key, paths to the fields that will be used as a primary key. If not provided by the source, the end user will have to specify the primary key themselves. */
  sourceDefinedPrimaryKey?: string[][];
  /** Optional Source-defined namespace. Airbyte streams from the same sources should have the same namespace. Currently only used by JDBC destinations to determine what schema to write to. */
  namespace?: string;
}

/**
 * each stream is split in two parts; the immutable schema from source and mutable configuration for destination
 */
export interface AirbyteStreamAndConfiguration {
  stream?: AirbyteStream;
  config?: AirbyteStreamConfiguration;
}

/**
 * describes the available schema (catalog).
 */
export interface AirbyteCatalog {
  streams: AirbyteStreamAndConfiguration[];
}

/**
 * type/source of logs produced
 */
export type LogType = typeof LogType[keyof typeof LogType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const LogType = {
  server: 'server',
  scheduler: 'scheduler',
} as const;

export interface LogsRequestBody {
  logType: LogType;
}

export type CheckOperationReadStatus =
  typeof CheckOperationReadStatus[keyof typeof CheckOperationReadStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CheckOperationReadStatus = {
  succeeded: 'succeeded',
  failed: 'failed',
} as const;

export interface CheckOperationRead {
  status: CheckOperationReadStatus;
  message?: string;
}

export interface OperatorDbt {
  gitRepoUrl: string;
  gitRepoBranch?: string;
  dockerImage?: string;
  dbtArguments?: string;
}

export type OperatorNormalizationOption =
  typeof OperatorNormalizationOption[keyof typeof OperatorNormalizationOption];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OperatorNormalizationOption = {
  basic: 'basic',
} as const;

export interface OperatorNormalization {
  option?: OperatorNormalizationOption;
}

export type OperatorType = typeof OperatorType[keyof typeof OperatorType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OperatorType = {
  normalization: 'normalization',
  dbt: 'dbt',
} as const;

export interface OperatorConfiguration {
  operatorType: OperatorType;
  normalization?: OperatorNormalization;
  dbt?: OperatorDbt;
}

export interface OperationCreate {
  workspaceId: WorkspaceId;
  name: string;
  operatorConfiguration: OperatorConfiguration;
}

export type OperationId = string;

export interface OperationRead {
  workspaceId: WorkspaceId;
  operationId: OperationId;
  name: string;
  operatorConfiguration: OperatorConfiguration;
}

export interface OperationReadList {
  operations: OperationRead[];
}

export interface WebBackendOperationCreateOrUpdate {
  operationId?: OperationId;
  workspaceId: WorkspaceId;
  name: string;
  operatorConfiguration: OperatorConfiguration;
}

export interface OperationUpdate {
  operationId: OperationId;
  name: string;
  operatorConfiguration: OperatorConfiguration;
}

export interface OperationIdRequestBody {
  operationId: OperationId;
}

/**
 * Method used for computing final namespace in destination
 */
export type NamespaceDefinitionType =
  typeof NamespaceDefinitionType[keyof typeof NamespaceDefinitionType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const NamespaceDefinitionType = {
  source: 'source',
  destination: 'destination',
  customformat: 'customformat',
} as const;

export type ConnectionScheduleTimeUnit =
  typeof ConnectionScheduleTimeUnit[keyof typeof ConnectionScheduleTimeUnit];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ConnectionScheduleTimeUnit = {
  minutes: 'minutes',
  hours: 'hours',
  days: 'days',
  weeks: 'weeks',
  months: 'months',
} as const;

/**
 * if null, then no schedule is set.
 */
export interface ConnectionSchedule {
  units: number;
  timeUnit: ConnectionScheduleTimeUnit;
}

/**
 * Active means that data is flowing through the connection. Inactive means it is not. Deprecated means the connection is off and cannot be re-activated. the schema field describes the elements of the schema that will be synced.
 */
export type ConnectionStatus =
  typeof ConnectionStatus[keyof typeof ConnectionStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ConnectionStatus = {
  active: 'active',
  inactive: 'inactive',
  deprecated: 'deprecated',
} as const;

export interface ConnectionReadList {
  connections: ConnectionRead[];
}

export interface WebBackendConnectionSearch {
  connectionId?: ConnectionId;
  name?: string;
  namespaceDefinition?: NamespaceDefinitionType;
  /** Used when namespaceDefinition is 'customformat'. If blank then behaves like namespaceDefinition = 'destination'. If "${SOURCE_NAMESPACE}" then behaves like namespaceDefinition = 'source'. */
  namespaceFormat?: string;
  /** Prefix that will be prepended to the name of each stream when it is written to the destination. */
  prefix?: string;
  sourceId?: SourceId;
  destinationId?: DestinationId;
  schedule?: ConnectionSchedule;
  status?: ConnectionStatus;
  source?: SourceSearch;
  destination?: DestinationSearch;
}

export interface WebBackendConnectionCreate {
  /** Optional name of the connection */
  name?: string;
  namespaceDefinition?: NamespaceDefinitionType;
  /** Used when namespaceDefinition is 'customformat'. If blank then behaves like namespaceDefinition = 'destination'. If "${SOURCE_NAMESPACE}" then behaves like namespaceDefinition = 'source'. */
  namespaceFormat?: string;
  /** Prefix that will be prepended to the name of each stream when it is written to the destination. */
  prefix?: string;
  sourceId: SourceId;
  destinationId: DestinationId;
  operationIds?: OperationId[];
  syncCatalog?: AirbyteCatalog;
  schedule?: ConnectionSchedule;
  status: ConnectionStatus;
  resourceRequirements?: ResourceRequirements;
  operations?: OperationCreate[];
  sourceCatalogId?: string;
}

export interface ConnectionCreate {
  /** Optional name of the connection */
  name?: string;
  namespaceDefinition?: NamespaceDefinitionType;
  /** Used when namespaceDefinition is 'customformat'. If blank then behaves like namespaceDefinition = 'destination'. If "${SOURCE_NAMESPACE}" then behaves like namespaceDefinition = 'source'. */
  namespaceFormat?: string;
  /** Prefix that will be prepended to the name of each stream when it is written to the destination. */
  prefix?: string;
  sourceId: SourceId;
  destinationId: DestinationId;
  operationIds?: OperationId[];
  syncCatalog?: AirbyteCatalog;
  schedule?: ConnectionSchedule;
  status: ConnectionStatus;
  resourceRequirements?: ResourceRequirements;
  sourceCatalogId?: string;
}

export interface DbMigrationRequestBody {
  database: string;
}

export type ConnectionId = string;

export interface WebBackendConnectionUpdate {
  /** Name that will be set to the connection */
  name?: string;
  connectionId: ConnectionId;
  namespaceDefinition?: NamespaceDefinitionType;
  /** Used when namespaceDefinition is 'customformat'. If blank then behaves like namespaceDefinition = 'destination'. If "${SOURCE_NAMESPACE}" then behaves like namespaceDefinition = 'source'. */
  namespaceFormat?: string;
  /** Prefix that will be prepended to the name of each stream when it is written to the destination. */
  prefix?: string;
  operationIds?: OperationId[];
  syncCatalog: AirbyteCatalog;
  schedule?: ConnectionSchedule;
  status: ConnectionStatus;
  resourceRequirements?: ResourceRequirements;
  withRefreshedCatalog?: boolean;
  skipReset?: boolean;
  operations?: WebBackendOperationCreateOrUpdate[];
  sourceCatalogId?: string;
}

export interface ConnectionUpdate {
  connectionId: ConnectionId;
  namespaceDefinition?: NamespaceDefinitionType;
  /** Used when namespaceDefinition is 'customformat'. If blank then behaves like namespaceDefinition = 'destination'. If "${SOURCE_NAMESPACE}" then behaves like namespaceDefinition = 'source'. */
  namespaceFormat?: string;
  /** Name that will be set to this connection */
  name?: string;
  /** Prefix that will be prepended to the name of each stream when it is written to the destination. */
  prefix?: string;
  operationIds?: OperationId[];
  syncCatalog: AirbyteCatalog;
  schedule?: ConnectionSchedule;
  status: ConnectionStatus;
  resourceRequirements?: ResourceRequirements;
  sourceCatalogId?: string;
}

export interface WebBackendConnectionRequestBody {
  withRefreshedCatalog?: boolean;
  connectionId: ConnectionId;
}

export interface ConnectionIdRequestBody {
  connectionId: ConnectionId;
}

export type ReleaseStage = typeof ReleaseStage[keyof typeof ReleaseStage];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ReleaseStage = {
  alpha: 'alpha',
  beta: 'beta',
  generally_available: 'generally_available',
  custom: 'custom',
} as const;

export interface DestinationReadList {
  destinations: DestinationRead[];
}

/**
 * The values required to configure the destination. The schema for this must match the schema return by destination_definition_specifications/get for the destinationDefinition.
 */
export type DestinationConfiguration = unknown;

export interface DestinationSearch {
  destinationDefinitionId?: DestinationDefinitionId;
  destinationId?: DestinationId;
  workspaceId?: WorkspaceId;
  connectionConfiguration?: DestinationConfiguration;
  name?: string;
  destinationName?: string;
}

export interface DestinationCloneConfiguration {
  connectionConfiguration?: DestinationConfiguration;
  name?: string;
}

export interface DestinationUpdate {
  destinationId: DestinationId;
  connectionConfiguration: DestinationConfiguration;
  name: string;
}

export interface DestinationCreate {
  workspaceId: WorkspaceId;
  name: string;
  destinationDefinitionId: DestinationDefinitionId;
  connectionConfiguration: DestinationConfiguration;
}

export interface DestinationCoreConfig {
  destinationDefinitionId: DestinationDefinitionId;
  connectionConfiguration: DestinationConfiguration;
}

export type DestinationId = string;

export interface ConnectionSearch {
  connectionId?: ConnectionId;
  name?: string;
  namespaceDefinition?: NamespaceDefinitionType;
  /** Used when namespaceDefinition is 'customformat'. If blank then behaves like namespaceDefinition = 'destination'. If "${SOURCE_NAMESPACE}" then behaves like namespaceDefinition = 'source'. */
  namespaceFormat?: string;
  /** Prefix that will be prepended to the name of each stream when it is written to the destination. */
  prefix?: string;
  sourceId?: SourceId;
  destinationId?: DestinationId;
  schedule?: ConnectionSchedule;
  status?: ConnectionStatus;
  source?: SourceSearch;
  destination?: DestinationSearch;
}

export interface ConnectionRead {
  connectionId: ConnectionId;
  name: string;
  namespaceDefinition?: NamespaceDefinitionType;
  /** Used when namespaceDefinition is 'customformat'. If blank then behaves like namespaceDefinition = 'destination'. If "${SOURCE_NAMESPACE}" then behaves like namespaceDefinition = 'source'. */
  namespaceFormat?: string;
  /** Prefix that will be prepended to the name of each stream when it is written to the destination. */
  prefix?: string;
  sourceId: SourceId;
  destinationId: DestinationId;
  operationIds?: OperationId[];
  syncCatalog: AirbyteCatalog;
  schedule?: ConnectionSchedule;
  status: ConnectionStatus;
  resourceRequirements?: ResourceRequirements;
  sourceCatalogId?: string;
}

export interface DestinationRead {
  destinationDefinitionId: DestinationDefinitionId;
  destinationId: DestinationId;
  workspaceId: WorkspaceId;
  connectionConfiguration: DestinationConfiguration;
  name: string;
  destinationName: string;
}

/**
 * The values required to configure the destination. The schema for this should have an id of the existing destination along with the configuration you want to change in case.
 */
export interface DestinationCloneRequestBody {
  destinationCloneId: DestinationId;
  destinationConfiguration?: DestinationCloneConfiguration;
}

export interface DestinationIdRequestBody {
  destinationId: DestinationId;
}

/**
 * The specification for what values are required to configure the destinationDefinition.
 */
export type DestinationDefinitionSpecification = unknown;

export interface DestinationDefinitionSpecificationRead {
  destinationDefinitionId: DestinationDefinitionId;
  documentationUrl?: string;
  connectionSpecification?: DestinationDefinitionSpecification;
  authSpecification?: DestinationAuthSpecification;
  advancedAuth?: AdvancedAuth;
  jobInfo: SynchronousJobRead;
  supportedDestinationSyncModes?: DestinationSyncMode[];
  supportsDbt?: boolean;
  supportsNormalization?: boolean;
}

export interface PrivateDestinationDefinitionReadList {
  destinationDefinitions: PrivateDestinationDefinitionRead[];
}

export interface DestinationDefinitionIdWithWorkspaceId {
  destinationDefinitionId: DestinationDefinitionId;
  workspaceId: WorkspaceId;
}

export interface CustomDestinationDefinitionCreate {
  workspaceId: WorkspaceId;
  destinationDefinition: DestinationDefinitionCreate;
}

export interface DestinationDefinitionRead {
  destinationDefinitionId: DestinationDefinitionId;
  name: string;
  dockerRepository: string;
  dockerImageTag: string;
  documentationUrl: string;
  icon?: string;
  releaseStage?: ReleaseStage;
  /** The date when this connector was first released, in yyyy-mm-dd format. */
  releaseDate?: string;
  resourceRequirements?: ActorDefinitionResourceRequirements;
}

export interface PrivateDestinationDefinitionRead {
  destinationDefinition: DestinationDefinitionRead;
  granted: boolean;
}

export interface DestinationDefinitionReadList {
  destinationDefinitions: DestinationDefinitionRead[];
}

export interface DestinationDefinitionUpdate {
  destinationDefinitionId: DestinationDefinitionId;
  dockerImageTag?: string;
  resourceRequirements?: ActorDefinitionResourceRequirements;
}

export interface CustomDestinationDefinitionUpdate {
  workspaceId: WorkspaceId;
  destinationDefinition: DestinationDefinitionUpdate;
}

export interface DestinationDefinitionCreate {
  name: string;
  dockerRepository: string;
  dockerImageTag: string;
  documentationUrl: string;
  icon?: string;
  resourceRequirements?: ActorDefinitionResourceRequirements;
}

export interface DestinationDefinitionIdRequestBody {
  destinationDefinitionId: DestinationDefinitionId;
}

export type DestinationAuthSpecification = AuthSpecification;

export type DestinationDefinitionId = string;

/**
 * Returns the results of a discover catalog job. If the job was not successful, the catalog field will not be present. jobInfo will aways be present and its status be used to determine if the job was successful or not.
 */
export interface SourceDiscoverSchemaRead {
  catalog?: AirbyteCatalog;
  jobInfo: SynchronousJobRead;
  catalogId?: string;
}

export interface SourceReadList {
  sources: SourceRead[];
}

export interface SourceDiscoverSchemaRequestBody {
  sourceId: SourceId;
  disable_cache?: boolean;
}

/**
 * The values required to configure the source. The schema for this must match the schema return by source_definition_specifications/get for the source.
 */
export type SourceConfiguration = unknown;

export interface SourceCreate {
  sourceDefinitionId: SourceDefinitionId;
  connectionConfiguration: SourceConfiguration;
  workspaceId: WorkspaceId;
  name: string;
}

export interface SourceCoreConfig {
  sourceDefinitionId: SourceDefinitionId;
  connectionConfiguration: SourceConfiguration;
}

export interface SourceCloneConfiguration {
  connectionConfiguration?: SourceConfiguration;
  name?: string;
}

export type SourceId = string;

export interface SourceRead {
  sourceDefinitionId: SourceDefinitionId;
  sourceId: SourceId;
  workspaceId: WorkspaceId;
  connectionConfiguration: SourceConfiguration;
  name: string;
  sourceName: string;
}

export interface SourceUpdate {
  sourceId: SourceId;
  connectionConfiguration: SourceConfiguration;
  name: string;
}

/**
 * The values required to configure the source. The schema for this should have an id of the existing source along with the configuration you want to change in case.
 */
export interface SourceCloneRequestBody {
  sourceCloneId: SourceId;
  sourceConfiguration?: SourceCloneConfiguration;
}

export interface SourceIdRequestBody {
  sourceId: SourceId;
}

/**
 * An object containing any metadata needed to describe this connector's Oauth flow
 */
export interface OAuth2Specification {
  /** A list of strings representing a pointer to the root object which contains any oauth parameters in the ConnectorSpecification.
Examples:
if oauth parameters were contained inside the top level, rootObject=[] If they were nested inside another object {'credentials': {'app_id' etc...}, rootObject=['credentials'] If they were inside a oneOf {'switch': {oneOf: [{client_id...}, {non_oauth_param]}},  rootObject=['switch', 0]  */
  rootObject: unknown[];
  /** Pointers to the fields in the rootObject needed to obtain the initial refresh/access tokens for the OAuth flow. Each inner array represents the path in the rootObject of the referenced field. For example. Assume the rootObject contains params 'app_secret', 'app_id' which are needed to get the initial refresh token. If they are not nested in the rootObject, then the array would look like this [['app_secret'], ['app_id']] If they are nested inside an object called 'auth_params' then this array would be [['auth_params', 'app_secret'], ['auth_params', 'app_id']] */
  oauthFlowInitParameters: string[][];
  /** Pointers to the fields in the rootObject which can be populated from successfully completing the oauth flow using the init parameters. This is typically a refresh/access token. Each inner array represents the path in the rootObject of the referenced field. */
  oauthFlowOutputParameters: string[][];
}

export type AuthSpecificationAuthType =
  typeof AuthSpecificationAuthType[keyof typeof AuthSpecificationAuthType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AuthSpecificationAuthType = {
  oauth20: 'oauth2.0',
} as const;

export interface AuthSpecification {
  auth_type?: AuthSpecificationAuthType;
  oauth2Specification?: OAuth2Specification;
}

export type SourceAuthSpecification = AuthSpecification;

/**
 * The specification for what values are required to configure the sourceDefinition.
 */
export interface SourceDefinitionSpecification {
  [key: string]: any;
}

export interface SourceDefinitionSpecificationRead {
  sourceDefinitionId: SourceDefinitionId;
  documentationUrl?: string;
  connectionSpecification?: SourceDefinitionSpecification;
  authSpecification?: SourceAuthSpecification;
  advancedAuth?: AdvancedAuth;
  jobInfo: SynchronousJobRead;
}

export interface PrivateSourceDefinitionRead {
  sourceDefinition: SourceDefinitionRead;
  granted: boolean;
}

export interface PrivateSourceDefinitionReadList {
  sourceDefinitions: PrivateSourceDefinitionRead[];
}

export interface CustomSourceDefinitionUpdate {
  workspaceId: WorkspaceId;
  sourceDefinition: SourceDefinitionUpdate;
}

export interface SourceDefinitionCreate {
  name: string;
  dockerRepository: string;
  dockerImageTag: string;
  documentationUrl: string;
  icon?: string;
  resourceRequirements?: ActorDefinitionResourceRequirements;
}

export interface CustomSourceDefinitionCreate {
  workspaceId: WorkspaceId;
  sourceDefinition: SourceDefinitionCreate;
}

export type SourceDefinitionId = string;

export interface SourceSearch {
  sourceDefinitionId?: SourceDefinitionId;
  sourceId?: SourceId;
  workspaceId?: WorkspaceId;
  connectionConfiguration?: SourceConfiguration;
  name?: string;
  sourceName?: string;
}

export interface SourceDefinitionIdWithWorkspaceId {
  sourceDefinitionId: SourceDefinitionId;
  workspaceId: WorkspaceId;
}

export interface SourceDefinitionRead {
  sourceDefinitionId: SourceDefinitionId;
  name: string;
  dockerRepository: string;
  dockerImageTag: string;
  documentationUrl?: string;
  icon?: string;
  releaseStage?: ReleaseStage;
  /** The date when this connector was first released, in yyyy-mm-dd format. */
  releaseDate?: string;
  resourceRequirements?: ActorDefinitionResourceRequirements;
}

export interface SourceDefinitionReadList {
  sourceDefinitions: SourceDefinitionRead[];
}

/**
 * Update the SourceDefinition. Currently, the only allowed attribute to update is the default docker image version.
 */
export interface SourceDefinitionUpdate {
  sourceDefinitionId: SourceDefinitionId;
  dockerImageTag: string;
  resourceRequirements?: ActorDefinitionResourceRequirements;
}

export interface SourceDefinitionIdRequestBody {
  sourceDefinitionId: SourceDefinitionId;
}

export interface SlugRequestBody {
  slug: string;
}

export interface WebBackendWorkspaceStateResult {
  hasConnections: boolean;
  hasSources: boolean;
  hasDestinations: boolean;
}

export interface WebBackendWorkspaceState {
  workspaceId: WorkspaceId;
}

export interface WorkspaceGiveFeedback {
  workspaceId: WorkspaceId;
}

export interface WorkspaceUpdate {
  workspaceId: WorkspaceId;
  email?: string;
  initialSetupComplete: boolean;
  displaySetupWizard?: boolean;
  anonymousDataCollection: boolean;
  news: boolean;
  securityUpdates: boolean;
  notifications?: Notification[];
}

export interface WorkspaceUpdateName {
  workspaceId: WorkspaceId;
  name: string;
}

export interface WorkspaceRead {
  workspaceId: WorkspaceId;
  customerId: CustomerId;
  email?: string;
  name: string;
  slug: string;
  initialSetupComplete: boolean;
  displaySetupWizard?: boolean;
  anonymousDataCollection?: boolean;
  news?: boolean;
  securityUpdates?: boolean;
  notifications?: Notification[];
  firstCompletedSync?: boolean;
  feedbackDone?: boolean;
}

export interface WorkspaceReadList {
  workspaces: WorkspaceRead[];
}

export interface WorkspaceIdRequestBody {
  workspaceId: WorkspaceId;
}

export type NotificationReadStatus =
  typeof NotificationReadStatus[keyof typeof NotificationReadStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const NotificationReadStatus = {
  succeeded: 'succeeded',
  failed: 'failed',
} as const;

export interface NotificationRead {
  status: NotificationReadStatus;
  message?: string;
}

export type NotificationType =
  typeof NotificationType[keyof typeof NotificationType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const NotificationType = {
  slack: 'slack',
  customerio: 'customerio',
} as const;

export interface CustomerioNotificationConfiguration {
  [key: string]: any;
}

export interface SlackNotificationConfiguration {
  webhook: string;
}

export interface Notification {
  notificationType: NotificationType;
  sendOnSuccess: boolean;
  sendOnFailure: boolean;
  slackConfiguration?: SlackNotificationConfiguration;
  customerioConfiguration?: CustomerioNotificationConfiguration;
}

export interface WorkspaceCreate {
  email?: string;
  anonymousDataCollection?: boolean;
  name: string;
  news?: boolean;
  securityUpdates?: boolean;
  notifications?: Notification[];
  displaySetupWizard?: boolean;
}

export type CustomerId = string;

export type WorkspaceId = string;
